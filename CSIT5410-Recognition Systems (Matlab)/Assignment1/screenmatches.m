function indices=screenmatches(I1,I2,matches,loc1match,des1match,loc2match,des2match)
%   This function screens out incorrect matched keypoints produced by
%   match(I1,I2) function.
%
%   Input Parameters:
%   I1, I2 input images.
%
%   matches: 2-by-K matrix, in which matches(1:2,i) are the indices of 
%   the keypoints for the ith match. It is generated by matches=match(I1,I2).
%
%   loc1match and loc2match: K-by-4 matrix, in which each row has the 4 
%   values for a matched keypoint location (row, column, scale, orientation).
%   The orientation is in the range [-PI, PI] radians. K is the number of
%   matched keypoints.
%   loc1match is the keypoint location vector for I1 and loc2match is the 
%   keypoint location vector for I2.
%
%   des1match and des2match: a K-by-128 matrix, where each row gives an 
%   invariant descriptor for one of the K matched keypoints. K is the number
%   of matched keypoints.
%   dse1match is the matched keypoint descriptor for I1 and des2match is the 
%   matched keypoint descriptor for I2.
%
%   Output Parameters:
%   indices = 1-by-M matrix, each element indicates the position index of a
%   correct matched keypoint in the vector "matches" after applying screen 
%   alogrithm.
%   
%   This program also plots the matched keypoints locations before and
%   after screening.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Between all pairs of matching features, compute
% orientation difference, scale ratio, and center offset
allScales = zeros(1,size(matches,2)); % Store computed values
allAngs = zeros(1,size(matches,2));
allX = zeros(1,size(matches,2));
allY = zeros(1,size(matches,2));
for i=1:size(matches, 2)
fprintf('Match %d: image 1 (scale,orient = %f,%f) matches', ...
i, loc1match(i,3), loc1match(i,4));
fprintf(' image 2 (scale,orient = %f,%f)\n', ...
loc2match(i,3), loc2match(i,4));
scaleRatio = loc1match(i,3)/loc2match(i,3);
dTheta = loc1match(i,4) - loc2match(i,4);
% Force dTheta to be between -pi and +pi
while dTheta > pi dTheta = dTheta - 2*pi; end
while dTheta < -pi dTheta = dTheta + 2*pi; end
allScales(i) = scaleRatio;
allAngs(i) = dTheta;
x1 = loc1match(i,1); % the feature in image 1
y1 = loc1match(i,2);
x2 = loc2match(i,1); % the feature in image 2
y2 = loc2match(i,2);
% The "center" of the object in image 1 is located at an offset of
% (-x1,-y1) relative to the detected feature. We need to scale and rotate
% this offset and apply it to the image 2 location.
offset = [-x1; -y1];
offset = offset / scaleRatio; % Scale to match image 2 scale
offset = [cos(dTheta) +sin(dTheta); -sin(dTheta) cos(dTheta)]*offset;
allX(i) = x2 + offset(1);
allY(i) = y2 + offset(2);
end
figure, plot(allScales, allAngs, '.'), xlabel('scale'), ylabel('angle');
figure, plot(allX, allY, '.'), xlabel('x'), ylabel('y');
% Use a coarse Hough space.
% Dimensions are [angle, scale, x, y]
% Define bin centers
aBin = -pi:(pi/4):pi;
sBin = 0.5:(2):10;
xBin = 1:(size(I2,2)/5):size(I2,2);
yBin = 1:(size(I2,1)/5):size(I2,1);
H = zeros(length(aBin), length(sBin), length(xBin), length(yBin));
for i=1:size(matches, 2)
a = allAngs(i);
s = allScales(i);
x = allX(i);
y = allY(i);
% Find bin that is closest to a,s,x,y
[temp, ia] = min(abs(a-aBin));
[temp, is] = min(abs(s-sBin));
[temp, ix] = min(abs(x-xBin));
[temp, iy] = min(abs(y-yBin));
H(ia,is,ix,iy) = H(ia,is,ix,iy) + 1; % Inc accumulator array
end
% Find all bins with 3 or more features
[ap,sp,xp,yp] = ind2sub(size(H), find(H>=3));
fprintf('Peaks in the Hough array:\n');
for i=1:length(ap)
fprintf('%d: %d points, (a,s,x,y) = %f,%f,%f,%f\n', ...
i, H(ap(i), sp(i), xp(i), yp(i)), ...
aBin(ap(i)), sBin(sp(i)), xBin(xp(i)), yBin(yp(i)) );
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Get the features corresponding to the largest bin
nFeatures = max(H(:)); % Number of features in largest bin
fprintf('Largest bin contains %d features\n', nFeatures);
[ap,sp,xp,yp] = ind2sub(size(H), find(H == nFeatures));
indices = []; % Make a list of indices
for i=1:size(matches, 2)
a = allAngs(i);
s = allScales(i);
x = allX(i);
y = allY(i);
% Find bin that is closest to a,s,x,y
[temp, ia] = min(abs(a-aBin));
[temp, is] = min(abs(s-sBin));
[temp, ix] = min(abs(x-xBin));
[temp, iy] = min(abs(y-yBin));
if ia==ap(1) && is==sp(1) && ix==xp(1) && iy==yp(1)
indices = [indices i];
end
end
fprintf('Features belonging to highest peak:\n');
disp(indices); 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Show matches before screening
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
figure, imshow([I1,I2],[]);
o = size(I1,2) ;
line([loc1match(:,2)';loc2match(:,2)'+o], [loc1match(:,1)';loc2match(:,1)']) ;
for i=1:size(loc1match,1)
y = loc1match(i,1);
x = loc1match(i,2);
text(x,y,sprintf('%d',i), 'Color', 'r');
end
for i=1:size(loc2match,1)
y = loc2match(i,1);
x = loc2match(i,2);
text(x+o,y,sprintf('%d',i), 'Color', 'r');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Show matches after screening
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
figure, imshow([I1,I2],[]);
o = size(I1,2) ;
line([loc1match(indices,2)';loc2match(indices,2)'+o],[loc1match(indices,1)';loc2match(indices,1)']) ;
for i=1:length(indices)
y = loc1match(indices(i),1);
x = loc1match(indices(i),2);
text(x,y,sprintf('%d',indices(i)), 'Color', 'r');
end
for i=1:length(indices)
y = loc2match(indices(i),1);
x = loc2match(indices(i),2);
text(x+o,y,sprintf('%d',indices(i)), 'Color', 'r');
end
